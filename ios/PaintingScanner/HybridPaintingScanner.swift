import Foundation
import UIKit
import CoreImage
import AVFoundation

// IMPORTANT: After running `npx nitrogen`, update this class declaration to:
// class HybridPaintingScanner: HybridPaintingScannerSpec, IPDFCameraViewControllerDelegate {
// The generated HybridPaintingScannerSpec protocol will define the exact method signatures
class HybridPaintingScanner: IPDFCameraViewControllerDelegate {
    private var cameraViewController: IPDFCameraViewController?
    private var onRectangleDetectCallback: ((Dictionary<String, Any>) -> Void)?
    private var onPictureTakenCallback: ((Dictionary<String, Any>) -> Void)?
    
    // Store callback functions (Nitro function type)
    private var rectangleDetectFunction: ((Dictionary<String, Any>) -> Void)?
    private var pictureTakenFunction: ((Dictionary<String, Any>) -> Void)?
    
    // Configuration properties
    private var quality: Float = 0.8
    private var useBase64: Bool = false
    private var captureMultiple: Bool = false
    private var detectionCountBeforeCapture: Int = 0
    private var stableCounter: Int = 0
    private var saveInAppDocument: Bool = false
    
    init() {
        // Initialize camera view controller
        cameraViewController = IPDFCameraViewController()
        cameraViewController?.delegate = self
        cameraViewController?.enableBorderDetection = true
    }
    
    // MARK: - Lifecycle Methods
    
    func startScanning() {
        cameraViewController?.setupCameraView()
        cameraViewController?.start()
    }
    
    func stopScanning() {
        cameraViewController?.stop()
    }
    
    // MARK: - Capture Methods
    // Note: The actual return type will be Promise<T> as generated by nitrogen
    // This implementation uses async/await which Nitro bridges to Promise
    
    func capture() async throws -> Dictionary<String, Any> {
        return try await withCheckedThrowingContinuation { [weak self] continuation in
            guard let self = self, let cameraVC = self.cameraViewController else {
                continuation.resume(throwing: NSError(domain: "PaintingScanner", code: 1, userInfo: [NSLocalizedDescriptionKey: "Camera not initialized"]))
                return
            }
            guard let self = self, let cameraVC = self.cameraViewController else {
                reject("CAMERA_ERROR", "Camera not initialized", nil)
                return
            }
            
            cameraVC.captureImageWithCompletionHandler { croppedImage, initialImage, rectangleFeature in
                guard let cropped = croppedImage, let initial = initialImage else {
                    reject("CAPTURE_ERROR", "Failed to capture image", nil)
                    return
                }
                
                // Process images
                let croppedImageData = cropped.jpegData(compressionQuality: CGFloat(self.quality))
                let initialImageData = initial.jpegData(compressionQuality: CGFloat(self.quality))
                
                guard let croppedData = croppedImageData, let initialData = initialImageData else {
                    reject("PROCESSING_ERROR", "Failed to process image data", nil)
                    return
                }
                
                // Convert rectangle coordinates
                var rectangleCoordinates: Dictionary<String, Any>? = nil
                if let rect = rectangleFeature {
                    rectangleCoordinates = [
                        "topLeft": [
                            "y": rect.bottomLeft.x + 30,
                            "x": rect.bottomLeft.y
                        ],
                        "topRight": [
                            "y": rect.topLeft.x + 30,
                            "x": rect.topLeft.y
                        ],
                        "bottomLeft": [
                            "y": rect.bottomRight.x,
                            "x": rect.bottomRight.y
                        ],
                        "bottomRight": [
                            "y": rect.topRight.x,
                            "x": rect.topRight.y
                        ]
                    ]
                }
                
                var result: Dictionary<String, Any> = [:]
                
                if self.useBase64 {
                    result["croppedImage"] = croppedData.base64EncodedString(options: .lineLength64Characters)
                    result["initialImage"] = initialData.base64EncodedString(options: .lineLength64Characters)
                } else {
                    let dir = self.saveInAppDocument
                        ? FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!.path
                        : NSTemporaryDirectory()
                    
                    let timestamp = Int(Date().timeIntervalSince1970)
                    let croppedFilePath = "\(dir)/cropped_img_\(timestamp).jpeg"
                    let initialFilePath = "\(dir)/initial_img_\(timestamp).jpeg"
                    
                    try? croppedData.write(to: URL(fileURLWithPath: croppedFilePath))
                    try? initialData.write(to: URL(fileURLWithPath: initialFilePath))
                    
                    result["croppedImage"] = croppedFilePath
                    result["initialImage"] = initialFilePath
                }
                
                result["rectangleCoordinates"] = rectangleCoordinates ?? NSNull()
                
                // Call callback if set
                self.onPictureTakenCallback?(result)
                
                continuation.resume(returning: result)
                
                if !self.captureMultiple {
                    self.stopScanning()
                }
            }
        }
    }
    
    // MARK: - Image Processing
    
    func reapplyPerspectiveCrop(base64Image: String, coordinates: Dictionary<String, Any>, quality: Double) async throws -> String {
        guard !base64Image.isEmpty else {
            throw NSError(domain: "PaintingScanner", code: 2, userInfo: [NSLocalizedDescriptionKey: "Base64 image is empty"])
        }
        
        guard let topLeftObj = coordinates["topLeft"] as? Dictionary<String, Any>,
              let topRightObj = coordinates["topRight"] as? Dictionary<String, Any>,
              let bottomLeftObj = coordinates["bottomLeft"] as? Dictionary<String, Any>,
              let bottomRightObj = coordinates["bottomRight"] as? Dictionary<String, Any> else {
            throw NSError(domain: "PaintingScanner", code: 3, userInfo: [NSLocalizedDescriptionKey: "Invalid coordinates format"])
        }
            
            // Clean base64 string
            let cleanedBase64 = base64Image
                .replacingOccurrences(of: "\n", with: "")
                .replacingOccurrences(of: "\r", with: "")
                .replacingOccurrences(of: " ", with: "")
            
        guard let imageData = Data(base64Encoded: cleanedBase64, options: .ignoreUnknownCharacters),
              let originalImage = UIImage(data: imageData) else {
            throw NSError(domain: "PaintingScanner", code: 4, userInfo: [NSLocalizedDescriptionKey: "Failed to decode base64 image"])
        }
            
        // Fix orientation
        var processedImage = originalImage
        if originalImage.imageOrientation != .up {
            UIGraphicsBeginImageContextWithOptions(originalImage.size, false, originalImage.scale)
            originalImage.draw(in: CGRect(origin: .zero, size: originalImage.size))
            processedImage = UIGraphicsGetImageFromCurrentImageContext() ?? originalImage
            UIGraphicsEndImageContext()
        }
        
        guard let ciImage = CIImage(image: processedImage) else {
            throw NSError(domain: "PaintingScanner", code: 5, userInfo: [NSLocalizedDescriptionKey: "Failed to create CIImage"])
        }
            
        // Extract stored coordinates
        let storedTopLeftY = (topLeftObj["y"] as? Double) ?? 0
        let storedTopLeftX = (topLeftObj["x"] as? Double) ?? 0
        let storedTopRightY = (topRightObj["y"] as? Double) ?? 0
        let storedTopRightX = (topRightObj["x"] as? Double) ?? 0
        let storedBottomLeftY = (bottomLeftObj["y"] as? Double) ?? 0
        let storedBottomLeftX = (bottomLeftObj["x"] as? Double) ?? 0
        let storedBottomRightY = (bottomRightObj["y"] as? Double) ?? 0
        let storedBottomRightX = (bottomRightObj["x"] as? Double) ?? 0
        
        // Reverse transformation to get landscape CIRectangleFeature format
        let landscapeTopLeft = CGPoint(x: storedTopRightY - 30, y: storedTopRightX)
        let landscapeTopRight = CGPoint(x: storedBottomRightY, y: storedBottomRightX)
        let landscapeBottomLeft = CGPoint(x: storedTopLeftY - 30, y: storedTopLeftX)
        let landscapeBottomRight = CGPoint(x: storedBottomLeftY, y: storedBottomLeftX)
        
        // Apply perspective correction
        let newLeft = CGPoint(x: landscapeTopLeft.x + 30, y: landscapeTopLeft.y)
        let newRight = CGPoint(x: landscapeTopRight.x, y: landscapeTopRight.y)
        let newBottomLeft = CGPoint(x: landscapeBottomLeft.x + 30, y: landscapeBottomLeft.y)
        let newBottomRight = CGPoint(x: landscapeBottomRight.x, y: landscapeBottomRight.y)
        
        let rectangleCoordinates: [String: Any] = [
            "inputTopLeft": CIVector(cgPoint: newLeft),
            "inputTopRight": CIVector(cgPoint: newRight),
            "inputBottomLeft": CIVector(cgPoint: newBottomLeft),
            "inputBottomRight": CIVector(cgPoint: newBottomRight)
        ]
        
        let correctedImage = ciImage.applyingFilter("CIPerspectiveCorrection", parameters: rectangleCoordinates)
        
        guard let cgImage = CIContext().createCGImage(correctedImage, from: correctedImage.extent) else {
            throw NSError(domain: "PaintingScanner", code: 6, userInfo: [NSLocalizedDescriptionKey: "Failed to create CGImage"])
        }
        
        let finalImage = UIImage(cgImage: cgImage)
        guard let finalImageData = finalImage.jpegData(compressionQuality: CGFloat(quality)) else {
            throw NSError(domain: "PaintingScanner", code: 7, userInfo: [NSLocalizedDescriptionKey: "Failed to convert to JPEG"])
        }
        
        return finalImageData.base64EncodedString(options: .lineLength64Characters)
    }
    
    // MARK: - Configuration Setters
    
    func setOverlayColor(color: String) {
        // Parse hex color string to UIColor
        var hex = color.trimmingCharacters(in: .whitespacesAndNewlines)
        if hex.hasPrefix("#") {
            hex.removeFirst()
        }
        
        var rgb: UInt64 = 0
        Scanner(string: hex).scanHexInt64(&rgb)
        
        let r = CGFloat((rgb & 0xFF0000) >> 16) / 255.0
        let g = CGFloat((rgb & 0x00FF00) >> 8) / 255.0
        let b = CGFloat(rgb & 0x0000FF) / 255.0
        
        cameraViewController?.overlayColor = UIColor(red: r, green: g, blue: b, alpha: 0.5)
    }
    
    func setEnableTorch(enabled: Bool) {
        cameraViewController?.enableTorch = enabled
    }
    
    func setQuality(quality: Double) {
        self.quality = Float(quality)
    }
    
    func setUseBase64(useBase64: Bool) {
        self.useBase64 = useBase64
    }
    
    func setCaptureMultiple(captureMultiple: Bool) {
        self.captureMultiple = captureMultiple
    }
    
    func setDetectionCountBeforeCapture(count: Double) {
        self.detectionCountBeforeCapture = Int(count)
    }
    
    func setDetectionRefreshRateInMS(rate: Double) {
        cameraViewController?.detectionRefreshRateInMS = Int(rate)
    }
    
    func setSaturation(saturation: Double) {
        cameraViewController?.saturation = Float(saturation)
    }
    
    func setBrightness(brightness: Double) {
        cameraViewController?.brightness = Float(brightness)
    }
    
    func setContrast(contrast: Double) {
        cameraViewController?.contrast = Float(contrast)
    }
    
    func setUseFrontCam(useFrontCam: Bool) {
        cameraViewController?.useFrontCam = useFrontCam
    }
    
    func setSaveInAppDocument(saveInAppDocument: Bool) {
        self.saveInAppDocument = saveInAppDocument
    }
    
    // MARK: - Event Callbacks
    // These methods take a function as parameter and store it
    // The TypeScript spec defines: onRectangleDetect: (callback: (data) => void) => void
    
    func onRectangleDetect(callback: @escaping (Dictionary<String, Any>) -> Void) {
        self.rectangleDetectFunction = callback
        self.onRectangleDetectCallback = callback
    }
    
    func onPictureTaken(callback: @escaping (Dictionary<String, Any>) -> Void) {
        self.pictureTakenFunction = callback
        self.onPictureTakenCallback = callback
    }
    
    // MARK: - IPDFCameraViewControllerDelegate
    
    func didDetectRectangle(_ rectangle: CIRectangleFeature, withType type: IPDFRectangeType) {
        switch type {
        case .good:
            stableCounter += 1
        default:
            stableCounter = 0
        }
        
        let typeString: String
        switch type {
        case .good:
            typeString = "good"
        case .badAngle:
            typeString = "badAngle"
        case .tooFar:
            typeString = "tooFar"
        }
        
        let data: Dictionary<String, Any> = [
            "stableCounter": stableCounter,
            "lastDetectionType": typeString
        ]
        
        onRectangleDetectCallback?(data)
    }
    
    // MARK: - View Access (for React Native integration)
    
    func getView() -> UIView? {
        return cameraViewController
    }
}

// Note: This implementation will need to be updated once nitrogen generates the actual protocol
// The generated protocol will be named HybridPaintingScannerSpec and this class will conform to it
// Methods will be automatically bridged by Nitro's code generation

